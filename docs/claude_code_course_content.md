# Claude Code: A Highly Agentic Coding Assistant - Course Content

## Introduction

Welcome to Claude Code, the Highly Agentic Coding Assistant. This short course is built in partnership with Anthropic and Anthropic's Elie Schoppik is back to share with us best practices for how to use Claude Code. I'm really excited about this short course. Claude Code's my personal favorite coding assistant right now, and it has boosted my and many other developers' productivity by a large margin. And it is a tool with a lot of depth to it. And so I want to get together with Anthropic, to teach, hopefully the definitive course on all of the most important ideas behind how to use it in a systematic way. Thanks, Andrew. I'm excited to be back here and start like you mentioned from explaining what the tool is, how it works, all the way towards using it in parallel with many different tools including Git worktrees and MCP servers. What we've seen over the last couple years is AI assisted coding has evolved rapidly. It started from maybe people asking LLMs occasional coding questions. suggestions to then GitHub autocomplete to then, your various tools that became more and more autonomous. And Claude Code, when it was released, was definitely a step up in terms of the degree of agency or the amount of stuff that the coding assistant could do by itself. And so I think many people were surprised that you could set a task that Claude would work on for many minutes or sometimes even more than a few minutes. And now there are developers that are orchestrating not just a single Claude instance, but even several of them. working in parallel on different parts of a codebase. But coordinating all this has to set the best practices that is not widely known and if you have not worked with people close to the best practices, I think there could be a big uplift still for mastering these best practices and knowing how they drive that amazing productivity that I'm seeing many developers have using Claude Code. So as we start to talk about those best practices, a key tip for working with Claude Code is providing clear context to help Claude code achieve the task you want efficiently. This means pointing Claude code to the relevant files, clearly describing the features and functionality that you want and making sure that you're properly extending the capabilities of Claude code with MCP servers and other tools in that ecosystem. In this course, you'll apply those best practices to three different examples. We'll start with a RAG chatbot and you'll implement the features from the front end to the back end, including refactoring code, writing tests, and then using the GitHub integration to work with pull requests and fixing issues. You'll make use of many Claude Code features like planning, thinking modes, creating parallel sessions, and managing Claude's memory. For the second example, we'll shift gears and work with Jupyter notebooks to explore e-commerce data. We'll refactor notebooks using Claude Code, remove redundant code, and create powerful dashboards with web applications. Finally, we'll move to create a visual mockup based in Figma and use Claude Code, the Figma MCP server and a different MCP server to import the design, iterate, test, and build agentically a powerful front-end application. If you're not currently a Claude Code user, I think learning this set of ideas will give you a meaningful acceleration in the way that which you can engineer systems. And even if you are a current Claude Code user, I think having Ellie share these best practices with you in a comprehensive and systematic way, will, I hope, leave you with quite a few new things you try that will be useful. your work. I'd like to thank from DeepLearning.AI, Hawraa Salami, who had contributed to this course. In the next video, Elie will share Claude Code's underlying architecture, and you might be surprised by how simple the architecture is. Claude Code relies on just a small number of tools to search for patterns within your code files, to list directories, look at files, do regex. It does not rely on semantically embedding your code in the code base or transforming it into searchable structure. And one of the things that I think has made Claude Code effective is how it agentically can read through your code to take notes in a file called code.md to figure out autonomously what is going on your codebase to then drive decision-making on how to advance your code. That's right. And because of that, and not having a need to index the codebase, you can ensure the codebase stays local. We'll talk about some of the security ramifications with that. So let's get started. And I'll see you in the next video.

## What is Claude Code?

In this first lesson, we'll go through the agentic workflow of Claude Code, the tools it uses to navigate your codebase, and the memory it keeps across sessions. Let's dive in. So let's talk a little bit about what Claude Code actually is. When we talk about agentic systems, we think a lot about a model, a set of tools, and some environment to run those tools. Models are great at handling input and returning output. But in many situations, those models don't know about your codebase, how to find files, and how to handle multiple tasks. So instead of just talking directly to a model, we're going to provide a very lightweight harness for that model. And through the command line, we're going to use that harness to leverage the model's intelligence to perform complex coding tasks. So instead of giving a task directly to the model and trying to find all kinds of information in a codebase. We're going to provide a set of tools. We're going to provide an environment and a couple other pieces of functionality to enable the model to come through codebases and solve much more complex problems. What are those pieces of functionality that we're talking about here? Enabling the model to have memory, enabling our model here to remember preferences of the user and the codebase we're going through or the task at hand. also going to give the model an environment where it can figure out what data it needs, formulate a plan and then take action. With just a small amount of code, we can leverage the model's intelligence to achieve quite remarkable results. With Claude Code, your options are Opus or Sonnet, depending on the complexity, the kind of task you're handling, and your subscription. When we talk about what Claude Code can do, it's very tempting to just think this is the tool for for writing lots of code. But as we progress in this course, we're actually going to start with one of the most powerful features of Claude Code, which is its ability to discover, explain, and design. Before you start writing code with Claude Code, use it as a way to get up to speed on a code base. We'll talk quite a bit about writing code with Claude Code, but we'll also talk about ways in which you can use it outside of the terminal in environments like GitHub. We'll talk a bit bit about refactoring, debugging errors and where this tool really shines. Not only is this useful for coding, but also across data analysis and any environment where the model's intelligence can create compelling visualizations, assets or deliverables for you. We mentioned that we give the model a harness. We give the model an environment to gather context and take an action. We talked a bit about the memory that we provide to the model. And in a little bit, we'll talk about what that underlying memory looks like. Now, let's talk about the tools or additional functionality that we let the model know about. To give an illustration of tool use, you can imagine that the user asks what code is written in a particular file. The model does not know how to navigate or find files, and that's where tool use comes into play. Out of the box, Claude Code provides a relatively small list of tools. One of those being the ability to read a file. Now that the model knows what to do, it can go ahead and read that file, get the contents of that file, and return the data to a user. This ability of tool use allows the model to go from a simple assistant to an extremely sophisticated agentic tool. We mentioned some of the tools that Claude Code comes built in with. Here is a list of the tools that we have. Some of those for editing across different kinds of files. Some of those for reading across different files. and some for doing additional actions like finding patterns, searching things across the web, and even creating or running sub-agents to handle very difficult and challenging tasks. Finally, since we're in the command line, we're going to need a tool to execute bash or shell commands. Tool use is what allows Claude Code to gather the context and information that it needs. This allows Claude Code to tackle harder problems. It also allows Claude Code to not have to index your entire code base and lead into potential security concerns. Finally, Claude Code is quite extensible. While you just saw the list of tools that Claude Code comes built in with, you can also add additional tools by connecting to MCP servers. MCP, or the model context protocol, is an open-source model agnostic protocol that allows for data and AI systems to communicate easily. These MCP servers can add functionality to Claude Code for a variety of different tasks and we'll explore a few of them over this course. I want to take a little more time to talk about what we mean by not indexing a codebase. Instead of creating a structured representation of the codebase and constantly analyzing that, Claude Code instead uses a feature called agentic search. Instead of requiring that that codebase is sent to a server and potentially leaving the ecosystem that you're in, Claude Code instead uses one or many different agents and sets of tools to find what it's looking for in your codebase. This allows your code to not have to be completely added to context or to have to leave the ecosystem that it's in, which can create certain security considerations. When we talk about the memory of Claude or its ability to remember what has happened in previous conversations or across all kinds of actions. This is done using a markdown file called claude.md In your claude.md file, you can define common configurations or style guidelines. These files get automatically loaded into context when launched. The conversation that you have with claude code is stored locally on your machine. You can clear that over the course of a conversation, so you can start with a new context window. But if for some reason, you need to continue that previous one or resume the earlier conversation, you can do so easily. I'm going to head over to the terminal that I have inside of VS Code. And we can see I have a folder here called demo with nothing in it. So let's start by opening up Claude Code using the claude command. Depending on where this file is, and especially the first time, it may ask if I trust the files in this folder, which I do. We've gotten a couple nice tips here for getting started, but I'm just going to start with a very simple prompt. Make a cool visualization for me. I'm just getting started. What we're going to see here is Claude Code start to make a to-do list of actions to take. You can imagine this task might be to search across a codebase, to edit files, to write tests, to deliver insights, or in our case to create a visualization. Depending on how Claude is feeling, this might be particles or fireworks or something else, but I just want to show you how quickly out of the box you can start to see changes with Claude Code. Since we're doing this inside of Visual Studio Code and Claude Code has an integration with that editor, we're going to see visually the changes that are being made. I'll accept those and in future editions, I'll let Claude Code do that without requesting permission from me. We can see here, we have a visualization that's built. Let's go ahead and open it in the browser. I'll ask Claude Code to do that for me. It will confirm. This is the command. Let's go see what it looks like. And here we are with our visualization. Can add some particles. lookin' a bit better. You can toggle the animation, see what's going on, and clear what we have here. We can expand on this as much as we want. We can change the functionality, we can add whatever we want right here. But I just want to show you out of the box how seamless it is to get up and running with this particular tool. In the next lesson, we'll explore how to use Claude Code across a larger codebase and take a step back and see just how powerful it is for explaining larger and more complex code bases.

## Setup & Codebase Understanding

The first example we'll work on is an end-to-end RAG chatbot. Let's use Claude Code to explore the code base. Before we start using Claude Code to write lots of code for us, let's talk about how we can use this tool to get up to speed on larger code bases. Right here, I have an application where I can chat with Claude about course materials from Deep Learning AI. So let's try asking an outline of a course. For example, what is the outline of the MCP Build Rich-Context AI Apps with Anthropic. We'll see here that I'll get a response with quite a bit of detail around the lessons and descriptions for each of those lessons. With that in mind, let's see how we can get up to speed on the underlying code that powers this application. Back in VS Code, I have the terminal open here and I'm going to hop into Claude Code just by typing in claude and pressing enter. In this application, I can start chatting with my codebase. So I'm going to start with a high-level question just to give me an overview of the codebase. What we're going to see Claude Code do is agentically search over the codebase, figure out some of the most important files and give me a description of what's happening in this application. Instead of searching through each individual file, we're going to agentically search and find the most relevant ones. So here we're going to get some information about the architecture, the key components, some of the features, and now if there are particular things I want to dig into, I can easily do that. I can also ask other higher level questions like how are these documents processed? In this application, we're using Retrieval Augmented Generation to fetch information about these courses. If I want to get more information about that process, I can ask a question like this one. We like to say that Claude Code is a fantastic engineer alongside you, but it's an even better explainer. So as you're getting up to speed with new codebases, new data sets. First, start using Claude Code as a way to explain things to you, so that when you ask it to write code, you can have a better understanding of what's going on. Here we can see the sources in the code base that are actually splitting text into chunks, that are adding lesson context and that are storing course metadata. This ability to quickly get up to speed with a code base, especially when you might not be familiar with the underlying technology or language, is exceptionally valuable. Instead of navigating to each of these folders and figuring out what's going on, we can ask more specific questions and even get diagrams and visualizations made for us. So the first thing I'll ask Claude is to trace the process of handling a user's query from front end to back end. You can imagine you might have some limited knowledge in one of the parts of the stack or you're not familiar with how this is all happening. So Claude Code is going to give us quite some useful information here. What's useful when you're seeing Claude Code work is its ability to give you a bit of a to-do list, so you can start to understand what's happening. At any point in time, you can press escape and guide Claude Code to follow a different set of to-dos, but in this case, I feel pretty good about what it's doing. It's going to start tracing from the frontend, start following API endpoints, analyze our Retrieval Augmented Generation system, and then figure out how to actually generate the response. It's reading the appropriate files that are handling these particular tasks and finishing up its list to give us a powerful summary. As we're in this environment, we can stay within VS Code or open up Claude Code in its own dedicated terminal instance. That's completely up to you as you're working in this application. Once it's done, we can see a very detailed path for what's happening here. Not only can I read each of these step-by-step, I can even ask Claude to write this to a file, but I'm seeing in quite a bit of detail what's happening on the front end with some JavaScript, what happens once that reaches my back end, what the Retrieval Augmented Generation system is doing, how I'm generating a response. Finally, how I'm searching through my vector database, how I'm filtering what's necessary, getting a response back, and then finally, sending that to the user. There's a lot that's going on in this application. And I can use Claude to dive deeper into any of those pieces. But let's just say I learn best from visualizations. So let's ask Claude to draw a diagram that illustrates this flow. We can ask Claude to draw diagrams for web visualizations. We can ask for ASCII art. But let's see what Claude comes up with with its own intelligence and knowledge of how the application works. So let's see what Claude code has come up with. We've got a really nice diagram here showing us the step-by-step process. So it can't create these visual diagrams. We could always ask it to use some something like D3.js or recharts if we want something like a web application. But we can see right here, we've got a really nice diagram. From the front end, making a request to the back end, calling the necessary functions, generating the response necessary if there's any history involved, talking directly to the large language model with our system prompts and our tools and a query, figuring out where to go next, searching through our vector database using Chroma DB, getting back results formatting that, sending it to the model to produce a final response. There's quite a bit of detail that goes into this. And if we want, we can even augment Claude with additional tools for generating the visualizations that we want. But out of the box, just getting this information quickly and efficiently is going to help us get up to speed with this codebase in a fraction of time that we used to spend. So with that in mind, let's ask a very simple question, how do I run this application? You might be in a situation where there's a new technology here, a new idea. Very simply, it's nice to just know how to get up and running. I can see here, my API documentation, my web interface, and if there are any environment variables I need, I'm good to go. Now that you've gotten an idea of how to just start talking to Claude Code. Let's talk a little bit about some of the more powerful features with Claude Code. When you start working with an application in Claude Code, one of the first things we recommend you do is run a command called /init. You can see here in Claude Code, when I add this slash, we have a list of many built-in commands that I can use. /init allows me to initialize a CLAUDE.md file with the codebase documentation. The CLAUDE.md file is mission critical for introducing memory for Claude Code, so that it knows how best to work in your codebase. The CLAUDE.md file is very useful for specifying how you want things to be run. This could be your tests, this could be your linting, and any long-term memory that you want Claude to have each time you're working with Claude Code for this particular project. Instead of making this from scratch, /init is going to analyze the codebase to figure out at a high level what it should know about each time you're working with this application. There are three different CLAUDE.md files that you can make, like the one generated with /init all the way here on the left. This CLAUDE.md file lives in your application. You can have many of them in nested sub folders. But this is shared with other engineers and committed to your version control. Another option is if you have personal instructions and customizations, think specific for your editing environment and terminal environment, you can put that in a CLAUDE.local.md file. This is git ignored and not shared with other engineers. Finally, in your home directory, in the .claude folder, you can add a CLAUDE.md and you can think of this like a global claude.md for all projects on your machine. This is helpful if you want Claude to follow instructions across a wide range of projects that you build with Claude Code. We can go ahead and allow Claude Code to find different files so that it knows how best to create this CLAUDE.md file. This CLAUDE.md file is meant to be added to your current git project and shared with other team members. As more individuals work on the codebase, they can add to this CLAUDE.md file, and you can even nest CLAUDE.md files in subdirectories if you need more specific instructions for things like the backend or frontend or our docs that we have here. What's really nice about using a tool like Claude Code with Visual Studio Code, is that as I see changes to files, I can see those visually in my editor. And anytime that I am using a tool in Claude Code, it's going to ask me for permissions. This mission critical human in the loop is really important when you get up and running, and if you don't need Claude to ask you every single time, can always use this second option. We'll go ahead and auto accept those edits and we'll see that a CLAUDE.md file has been created for us. To give you a quick walk through, we can see it's given us a project overview, key technologies, an architectural overview, a nice little diagram here, some core components. and much more. If we want things to change to this particular CLAUDE.md, we can easily do so. As it continues searching the codebase, it makes additional edits here to my CLAUDE.md and gives me a summary of what's been done. When I'm using a tool like Claude Code in VS Code, I have the ability to specify which file I'm in and even get information about particular lines. To set this up, I'm going to use the /ide command. and I can see right here that I'm connected with Visual Studio Code. Now that I'm in Visual Studio Code, we can see right here that the second that I visit a file, it's tagged right here for what's going on. This gives Claude Code the right context for which file I'm in and if there are questions I have about that file, it makes it easier for Claude Code to identify that. If I ever want to make any changes to my CLAUDE.md file, I can manually write that if I'd like. Or I can use a handy command to go ahead and use this pound key and directly add to memory. So I'm just going to say here, always use UV. to run the server, do not use pip directly. This is a package manager in the Python ecosystem and I want to make sure that Claude doesn't get confused. When I use this shortcut, we can see there are different places where this memory can be saved. We mentioned there is the Project memory that is included in git for everyone on your team to use. We have local memory that is gitignored but just useful for you as the developer. and then User memory that is applicable to all projects you use with Claude Code. For this one, I'll just go ahead and update the project memory. I can see here, I've made that change. And if I look in my CLAUDE.md, I'll see right here, I have some mentions to using UV to make sure that I'm doing that correctly. If I want to be more specific, I can also say, make sure to use UV to manage all dependencies. I'll add this to my CLAUDE.md and we'll see right here that it's been added. If I take a quick look at this particular file, we can see any mention of dependencies now includes UV. We spoke a little bit about some of the commands that are built into Claude Code like /emit. There are a couple other useful ones that I want to showcase here. And in fact, we're going to see later on in this course, we can even make our own. One of the first ones I want to walk you through is /help. This shows me right off the bat a quick description of all the commands. and a quick summary. This is useful as you're getting up to speed with Claude code. The next one I want to showcase is a command called /clear. What this allows you to do is clear the conversation history and start from scratch. This is very helpful as you shift gears and build new features. This allows you to clear the context window and start fresh. If you want to continue the conversation, have a smaller context window, but still have a summary of what's been done, we also have this command /compact that allows you to clear the history, but keep a summary so that you can build off with Claude having an idea of what was done before. One more useful command is the escape key that allows you to get out of whatever command you're in. So if I'm going and trying to do something like /compact and I want to stop that process, I can always press escape. If I start a process with Claude Code to explain what is in the codebase. If I want to stop that process, escape will allow me to interrupt and continue, onwards. So don't feel like you have to wait for Claude Code if you're not getting what you need. In the next lesson, we'll start using Claude Code to build features, add to files, modify changes, and make sure we're doing the right thing along the way. Before we hop off, one last useful piece with Claude Code is its ability to work with Git. So I've made some small changes to this application, and I want to add and commit these changes. Instead of me manually have to write the Git commands, write a descriptive commit message, going to actually have Claude Code do that work for us. And what's really nice is Claude Code's ability to add and commit the necessary commands. I'll go ahead and add this particular file, not only commit, but you can see here, I've got this really nice descriptive commit message. That's incredibly useful as we start asking Claude Code about historical changes with git. and when we push this to GitHub and other people are reading the changes we made. So we'll add and commit and the next lesson, we'll use Claude Code to start writing lots of things for us.

## Adding Features

Now that you have an understanding of the chatbot codebase, let's add features to the UI and implement a new tool for the chatbot. Now that we've gotten up to speed on this codebase, let's talk a little bit about some features we might want to add. We saw before, in this application, when we ask for an outline of a course, we get some really detailed information and we even see some of the sources that are referenced. At the same time, when we see these sources that are referenced, it would be really nice to be able to click on these as links and go to the source of truth. So we want to build an interface where the front end and back end are correctly rendering links to show where this data is coming from and not just some text. So let's hop over to Claude and talk a little bit about how to get started. What we're going to do here instead of just asking Claude to implement the feature necessary, we're going to make use of two important pieces. The first one is referencing the correct file, and the second is using plan mode. When we talk about referencing the correct file, Claude Code is only as good as the context that you give it. So when you ask Claude Code to make changes, it's important to make sure that we're figuring out the right files we need to modify. We can have Claude Code try to figure this out, but if we know out of the box what files need to be modified, giving in Claude Code this context right away makes the tool much more efficient. So let's see how that's done. I'm going to open up Claude Code and to reference a file, I simply use this at and tag that file. For a folder, I can reference files inside. For a file directly, I can go ahead and even use tab to complete for the full file name. With that in mind, let's talk next about the second important piece when building features or making larger changes. Instead of having Claude trying to figure out what needs to be done and write the code right away. We're going to follow a slightly different pattern. We're going to plan first. We're going to have Claude create a detailed plan for what changes need to be done. And if we approve that plan, we're then going to have Claude Code make changes to quite a few files. When you have slightly larger changes to make, we always recommend starting with plan mode so you can give Claude the opportunity to figure out what needs to be done before it needs to make those changes. To activate plan mode, I'm going to press shift tab twice. And we'll see here that plan mode is on. Let's showcase what needs to be done. I'm going to bring in a prompt that I have here, and I'm going to ask it to build an interface with source citations. You can notice here that I'm referencing the correct files as well as referencing other files where changes need to be made. So let's give Claude the opportunity to come up up with a plan for how to solve this particular problem. As always, it's going to read through the files that it thinks are most necessary. It's going to trace its way from the front end to the back end and understand what needs to be implemented. Once we finish getting a plan, we're going to have the opportunity to either approve it or to give Claude some feedback for what might need to be changed. But here, Claude is not directly writing any code. As we see here, we can accept and then continue to auto-accept edits so we can don't have to keep asking for permission. We can manually approve them or we can tell Claude to change the plan. Taking a quick look at this, I feel pretty good about what we need to do. So let's use that plan with our auto-accept edits. If you ever want to turn this on on its own, you can press shift tab just one time. We'll see the to-do list necessary. We'll see what changes need to be made. And now we're going to let Claude Code write to the files that it seems necessary, and then we can test that the implementation works correctly. correctly. We'll see here, files are being modified, changes are being made to the codebase. And since we added the auto accept, we don't have to keep giving permission over and over. Very common workflow that we see is users start by asking for permission each time. And as more trust is given by the human to Claude Code, the auto-accept edits come on a bit more. We can see here finally, that we can start the application to test the implementation. But in fact, the server is running already. So I'm just going to tell Claude, no, thank you. I'll say right off the that, the server is running. No need to start it yourself. If I want Claude Code to always do that, this is a great opportunity to just put something into the CLAUDE.md file as well. Now that I've let Claude Code know that, it's going to tell me the changes that have been made. So let's test this. Now let's try asking the same question. Let's ask for an outline of a course. And if this has been built correctly, you should be able to see links below for each one of these particular features. If I take a look, right here I have links that will take me to the right place, but the interface is a little bit difficult to see because of this blue link color. If I'd like, I can go ahead and ask Claude Code to make the change necessary to do so. So let's go and follow up with Claude and ask it to make this interface a little bit more pleasant. One option that I have here is just to tell Claude. here is what I want. Another option is to use Claude's visual ability to take a look at a screenshot and analyze what needs to be changed. So let's take a screenshot of what this interface looks like. and we're going to go ahead and paste that into Claude Code. Back in Claude Code, when I paste that screenshot, I'm going to say, these links are hard to read. Can you make this more visually appealing? We're going to go ahead and give Claude the ability to analyze that image and figure out where things need to be changed on the front end. And we can see here I can see the issue. The links are using a default blue color. Let me go ahead and make a change. When you need Claude Code to make visual changes, taking screenshots and showing Claude Code the screenshot is a very powerful way of quickly iterating against what we need. Let's go back to the browser and see what things look like now. We'll ask again for an outline of a course. And if this is done what we've expected, we should see that these links are a bit nicer to take a look at. Let's take a look at our sources and look at that. Much better. The ability for Claude Code to see screenshots and make changes is one of the most commonly used features we see and incredibly valuable to build things quickly. If I want to see those changes to files, I can open those up in VS code and Claude Code here will notice I'm in that particular script and I can ask questions and get information necessary for those files. files. This is looking good. Let's add a new feature. Instead of building off in the context window what I have now, I'm going to start completely from scratch and clear the conversation history. This is going to allow me to have a longer context window to work with and not have Claude get potentially confused with things that it's seen before that are not relevant to what I'm building now. As we saw before, when we want to build newer features, we're going to use plan mode. In this particular application, I want to add the ability to start a new chat in my interface. So instead of having to refresh the page each time, I'd love for a button here to allow me to reset the conversation and start a new chat again. So let's build that. I'm going to activate plan mode. and I'm going to go ahead and bring in the prompt that I have here. I'll ask Claude Code to add a new chat button and when clicked, it should clear the conversation in the chat window. start a new session and handle the necessary clean up. If you ever need to make a new line and add more context, you can use backslash and press enter. So if there is more I want to add here, I can easily do so that's a bit more visually appealing. So let's have Claude Code figure out what needs to be built here. As we saw before, if there are changes to the front end that we need, it will find the necessary folders, changes to the back end, the same kind of thing. And here, it's going to come up with a comprehensive plan. This idea of being able to plan and think before taking actions is incredibly valuable to build the interfaces that you want. I can take a quick look through this plan. I can see what it's trying to do and I feel good, so let's build it. If at any point in time, I don't like what's being done, I can always press escape and navigate Claude Code in a different direction. As always, we'll see our to-do list that needs to be built. We'll see these files being updated since I have auto accept edits on and once that's done, we'll move on to the next step. We'll start seeing some JavaScript being added for when clicks occur, starting new conversations. We'll see clearing inputs and focusing, and now building a little bit of styling to match existing sections. We can see here, it's going to test the new functionality. And if I need to tell Claude to not run the server, I can gladly do so if I want. So here, instead of running the server, I'll just tell Claude, don't do it. And since I'm going to find myself doing that a lot, now is a good at the time to say, don't run the server using ./run.sh I will start it myself. I'm going to put this actually in the project memory. If I want all other developers to do the same. But maybe other developers might want to run the server themselves. So I'll put that in the project memory that's local and git ignored. So this might be a situation where I like to run the server myself, but maybe other developers don't. Great use case for that Claude local MD file. Now let's go back to the browser and see what we built. I'll refresh the page. And we've got this new chat button here. Let's see if it works. We'll ask again for an outline of the course. We can make sure that our source links look great. And if this does what's expected, we can click on this button and start a new conversation. That's looking good. Let's start a new chat. So, even though this is working, it still doesn't look exactly the way that I want. And I can take screenshots and go back and forth with Claude. or I can enhance the tools that Claude Code has out of the box using MCP servers. MCP or the Model Context Protocol, allows for tools like Claude Code to gain additional functionality to external data sources and systems. What I'm going to do here is add an MCP server for Playwright, a popular tool for opening up a browser, taking screenshots, and analyzing those screenshots. So instead of me manually having to take the screenshot and have a conversation with Claude, we're going to let Claude do it all by itself. The first thing I'm going to do is quit out of Claude Code and add the necessary MCP server. And the command to do so is claude mcp add, the name of our MCP server, which is playwright, and then the underlying command to start that MCP server. That is done using npx @playwright/mcp@latest. For any MCP server that you want to include, you can reference the documentation. All MCP servers will specify the necessary command to connect to that particular server. Let's open up Claude again and we'll see what our MCP server looks like. We can use the /mcp command and here we can see that we have connected successfully to the Playwright MCP server and we can see the tools available that the Playwright server is giving us. Things like evaluating JavaScript, uploading files, pressing a key, navigating, going back. All of these things that we might manually test, Playwright can do that programmatically for us. I'll press escape to go back a few times, and let's ask Claude Code to navigate to figure out how to build the necessary content. So let's go and ask Claude Code using the Playwright MCP server visit the page that we're at and view the new chat button. I want that button to look the same as the other links below for Courses and Try Asking. Make sure this is left aligned and that the border is removed. Before it starts taking this action, it's going to ask me for approval for these particular tools. We'll see that it will visit that page, take a screenshot and do do what's necessary. Let's follow that and not ask for permission each time to use this particular tool. We can see here that the browser has opened a new tab programmatically to our page to take a screenshot. We'll ask Claude Code to take that screenshot and analyze what it sees. Here it can see the exact issue that's happening and instead of us manually having to take the screenshots necessary, it can programmatically fix itself. We could have a more specific prompt as well, that keeps asking Claude Code to make those changes necessary. Since I don't have auto accept on, I can see the change that's being made in VS Code. And right out of the box, I don't see a border and background with this new change. That looks good to me. Let's make those changes and continue making other changes. I can see left align looking good. and any other changes that need to be made here. It's going to take another screenshot to verify that the changes it's made look correct. that it has the right icon prefixes used. match other sections. With that in mind, let's go see how he did. I'm going to refresh the page. and it's looking good. It's got an extra plus here. So why don't we go ahead and ask it to take that out. But it's left aligned and it's using the icon that we like before. So let's go ahead and fix this up and say, there are now two plus icons, remove the one closer to the text \"+ New Chat\" We can see here there's already a plus in the HTML content, so we'll remove that and let's see what's done here. So instead of adding that extra plus, we can see here what's being done. If we need another snapshot, we can visit and take a snapshot necessary. As we can see here, Claude Code saw there was not an open tab, so it fixed itself, opened it up again and took the necessary screenshot. Let's see what that looks like now. Much better. As you can imagine, building complex interfaces using tools like MCP playwright makes building, designing and testing a breeze. We've made some really nice front end changes. Let's now go and visit the back end. Like we did before, we're going to start fresh and instead of building off of this conversation, we're going to start with a new one. So let's clear the conversation history and start again. This time, we want to build some features on the back end. So let's put in a prompt, talk about what's going to be done here. I need to add another tool that allows me to visit a particular course and for each of those courses, see the lesson number and the lesson title and description about that as well. Right now, the data that I get when I take a look at a course is relatively high level. Let's see what I mean. What we're going to ask Claude Code to do here is to make a change to our search_tools.py file. Let's take a look at that. And in this file, we can see right now that we just have one tool for searching content and getting details about that particular course. This second tool is going to allow us to get more descriptive information for each of the lessons in these courses. So let's see what Claude can do. As we've done previously, let's make a plan and make sure we're first okay with that plan before we start making changes to individual files. Claude Code can see the current architecture, had to implement the outline tool, and since we have that CLAUDE.md previously, it's going to more quickly be able to understand what needs to be done. We can take a look at what needs to be implemented, we can make sure that we're doing the right things in the right files. We can see that once we create this tool, we update the system prompt to make sure that we get that additional data, and then we register that tool in our RAG system. As always, if there's anything we want to change or suggest, we can do that now. But let's see what Claude Code can do for us. If this works as expected, we should be able to ask questions about a course and get much more detail for those particular lessons in the course. We can see here that not only are we modifying the underlying Python code, but also the system prompt and here we're registering that new tool that we've made. Once we finished our to-do list, we can head back to the browser and see what things look like and if this has been implemented correctly. We'll see a nice summary of what's been made and we can always change things at any point in time. Back in the browser, let's go ahead and try asking for some information about a course. If this works as expected. We should be able to get more detailed information including a link for that particular course. Here, we can see the names of the lessons and if we would like, we can even build additional functionality to get sources for each one of those. In the next lesson, we'll talk about what happens when things go wrong and how we can use Claude Code to debug, to write tests, and make sure that we feel confident in the software that we're writing alongside Claude Code.

## Testing, Error Debugging and Code Refactoring

The codebase is now missing tests for evaluating the RAG pipeline of the chatbot. Let's implement these tests and use them to debug an error that the chatbot is having processing the queries, and finally, refactor how the chatbot handles its tool use. Let's dive in. So far we've seen how to get up to speed with codebases and implement features to build a slightly more powerful experience. Now let's go ahead and imagine that it's been some time since we've worked on this application. We're coming back and we want to start using it again. So let's hop back to our application and ask for some details on what's covered in Lesson 5. We might expect to see a response that gives us information, but right now, something's wrong. It might be tempting to just copy this error, put it into Claude, take a screenshot, hope it solves the problem. But we're going to do something a little bit different. Instead of just getting the answer that we might want or leading Claude on some wild goose chase. We're going to take a bit more of a methodical approach here. We know that things are wrong in our application, but we also know that we don't have too many tests here to programmatically verify that that's the case. So what we're going to do is put in a prompt that not only mentions what the error is, but also specifies where we need to write tests. If we go back to our code base, the error we're looking at could be from a variety of different Python files. In our AIGenerator, this is where we handle interactions with Anthropic's API. And there could be problems in the prompt or even some of the logic we have for getting this part working. In our rag_system.py, this is the orchestrator for everything that's happening with Retrieval Augmented Generation. And in our search_tools, here's where we define the underlying tool definition where there could potentially be problems. So what we're going to ask Claude to do is write tests for these specific files just to start. We're then going to ask Claude to run those tests and through that, verify what is not working and make the appropriate fix. What's so powerful about this approach is by starting with our tests, we can start to build a robust foundation for building more off of the codebase and understanding when things go wrong, why they're failing. So let's open up Claude and put in a prompt. Since this is a little bit more challenging, we're also going to ask Claude to think a lot. This is going to trigger Claude's ability to enable extended thinking and allocate a few more tokens towards the thinking process. we're also going to see this process and if something doesn't appear right, we can always stop Claude in its tracks. We'll go ahead and make sure the plan mode is on because first we want to make sure before Claude starts writing tests, it understands what it needs to do and we can approve that process. As we start to read the files necessary, we're going to see Claude's thinking process. We're not only going to see the files that we're reading, but also what it needs to examine and what it should do. So let's go see what Claude's plan has. It's It seems like there's some kind of configuration issue, maybe some complex tool calling with failure points and some limited error propagation between components. So it's possible that the error is just getting caught somewhere. It's then going to propose a structure for tests based on these files, which looks good to us. use the pytest framework and mock whatever it is in ChromaDB that we need to get some unit tests and integration tests up and running. You can see right now it's starting to make a folder for my tests, where it'll be running. writing these. It's a great start. We'll go ahead and make sure we add any necessary dependencies here as well with UV. Let's go install our dependencies, make sure we have pytest working as expected, and that looks good. We're also going to see the thinking part here to make sure that we're doing what's expected. As we start to write these particular tests, we can start exploring the code that's been written for us. Here we can see tests for the course search tool, fixtures and mocks that we need to make. This looks like a good start. We'll see the same thing for our AI generator. and our RAG system and our vector store. It seems like it's identified a critical config issue which may solve the bug, but writing these tests is going to give us complete assurance that this is actually the problem and that this is the correct fix. Now that we've created these tests, let's run them using UV. Let's go make sure we have the correct dependencies so that we can run those tests as expected. So from its finding, it's telling us that it's seems like there's something wrong with these max results or the number of chunks that were returning when we perform our vector search. So let's see what we're getting when we take a look at our MAX_RESULTS. And this confirms the issue that we have. For some reason, this happens to be zero. Once we go ahead and change this, we should expect that not only our tests are working as expected, but that the results we get are complete. We can verify this by taking a look and making sure we get the file that we expect. Now that Claude Code is wrapping up, it can provide a comprehensive summary of its findings, which I can wait to see or if I feel good now, I can stop Claude in its tracks. But I'll take a look at what it gives me. It's completed its debugging. It's found the critical issue, and it's created a few tests, as well as some infrastructure to keep running tests as we go forward. Let's go see if this worked as expected. Back in the browser, I'll start a new conversation, and let's ask that same question again and see if we get the result as expected. Instead of the query failing, we should expect to see information just about the lesson and that's exactly what we did. we have here. So not only have we fixed the bug, we built for ourselves a powerful infrastructure to keep running the application off of and make sure that as we make new changes, things are not breaking and we don't know why. Now that we got this application working, let's talk about a little bit of a refactor that I'd like to make in the codebase. Let's clear and start again with a new feature. So here in our ai_generator.py, we specify that we want one search per query maximum. While this leads to the expected behavior for relatively simple when we want to start doing more complex queries, comparing different courses, comparing their outlines, we're going to need more than one tool call. So what we're going to need is some kind of environment where we can either iteratively go through all the tools necessary or recursively solve that problem. If you're comfortable with this code and ecosystem, you can take a look at the class that we have here, which is a relatively simple way to talk directly to Anthropic models using our SDK, set your base_params and generate a response. But you can see here, as we build our system prompt, as we figure out the messages necessary and any tools, there's no iteration and back and forth to accumulate our tools necessary and have a multi-turn conversation with multiple tools being used. So let's refactor that. I've got a pretty long prompt here, so I'm going to go ahead and make a new markdown file and let's go call this backend-tool-refactor.md In this file, I want to walk through the prompt that I have where I'm going to ask Ask Claude to refactor the backend ai_generator.py to support two calls in separate rounds. The current behavior is what I'm describing as well as the desired behavior. While this might not be required, it's often helpful, as we've seen, to give Claude as much information as possible, especially when the tasks are a little bit more complex. We're also going to give Claude an example flow. Something like search for a course that discusses the same topic as another course. Just to give Claude a sense of what needs to be done. Notice here, there are a couple of different tools that need to be used as expected. We'll give Claude some requirements, and then a couple of notes as well to make sure we're doing the right thing. We're going to make sure that we write tests that verify external behavior instead of worrying about internal state details. Or we're also going to ask Claude to do is figure out a couple different plans. Don't implement any code, but dispatch two subagents to brainstorm potential options. In this situation, I'm not exactly sure what the optimal refactoring is. So instead of letting Claude Code decide just one option, I'm actually going to give it the opportunity to figure out multiple options in parallel. So let's use that particular prompt and I'll turn off auto accept to make sure that as I'm going through, I can confirm each of the changes that I want. So let's run that prompt. We should expect to see the two parallel subagents being dispatched using a tool called task. And as we see those agents dispatched, we'll start to see two plans for how we can solve this problem. It's then up to us to decide which one to implement. We can see that both of these are operating in parallel, reading across files and figuring out two different approaches for this refactor. So it looks like it's come back with some recommendations for how best to tackle this. One approach is iterative, another more comprehensive. We can see here that Claude is actually going to give us an option to choose either option B for better long-term maintainability or option A for a safer implementation. scroll up more. If I scroll up more, I can get some details into what it's trying to do. One option supporting some iteration for handling tools, the other for a slightly more complicated implementation for multi-round logic with different helper methods for that process. From first glance, it seems like approach A is a bit simpler. So why don't we start with that? I'm going to select approach A, but I'm also now going to enable plan mode to make sure I have a comprehensive plan and can accept before making the changes that I want. Let's implement approach A. and get a more detailed plan to verify that this is exactly what we want to do. We know that there needs to be some modification in the way that which we call these tools, but let's make sure this is all being done in the right place before we go ahead and have Claude Code write the solution for us. Now let's take a look at what's being done here. We'll update our method signature for a maximum number of rounds, update our system prompt, and here where the core refactoring is done in our handle tool execution. If this is done as expected, we should see the user query, we should see multiple tools being called and then a final response. This shouldn't modify anything else and should solve the problem for us. We can see here that this is backwards compatible, and we're not changing the internal RAG system or any API endpoints. So let's proceed and see if this can solve our problem for us. As we see what's being implemented, we can see changes to existing methods, and most importantly, we can see here that we're updating the tests and running the tests to verify that the implementation works correctly. Instead of context switching to the browser or asking other people to test, I can do this all from inside the terminal in Claude Code. So we'll see here, we're going to update our system prompt, make sure that our tests are as expected. And then we'll add a test to make sure the sequential tool calling works as expected. Let's run our tests, make sure they're passing as expected. Let's verify in the browser, this is doing what if you want. Let's try asking first for a details of a course's lesson. So here we can see that not only are we getting this information, but also the title here as well, as expected. We're getting information about this lesson, as well as some of the sections and topics discussed. Now let's do something a little more complex. What's so special about seeing the title here is that we don't get that with just one tool call. The first tool call just gives us an outline of the course. The second tool call gives us that detail of the particular lesson and in our case the title. Now let's ask, Are there any other courses that cover the same topic as Lesson 5 of the MCP course? In order to do this, we're going to need to make multiple tool calls to get information about this particular MCP course and outline and then information about other courses and their outlines to see if there's any overlap. Unfortunately, it looks like there are no other courses that cover building an MCP client, which does seem accurate. In this lesson, we've seen how to use Claude Code to not only fix bugs, but write tests throughout the entire process. We built for ourselves a solid foundation to keep coding on and made a nice refactor to get more complicated query answers appropriately. In the next lesson, we'll improve our productivity by running multiple sessions of Claude Code and making sure we don't have overlaps or overwrites using Git worktrees. I'll see you there.

## Adding Multiple Features Simultaneously

You can open multiple sessions with Claude Code to work on many features in parallel. To manage these sessions and make sure you're not overwriting the same file, you can use Git worktrees. So let's add Git worktrees to add three features to the chatbot in parallel. I'll see you there. So I'm going to hop back into Claude. And as we saw earlier, Claude Code comes built in with quite a few slash commands. But you can also make your own. To make your own custom commands, inside of the dot claude folder. Let's make a new folder called commands. And inside of here, we're going to make a markdown file with the name of the command that we'd like. The command here that I'm going to make is called implement feature. So I'll create a markdown file called implement-feature.md Inside here, I can place whatever I'd like. But what I want to show you that's very special is if you have any arguments you want to pass to your custom command, you can reference it using this $ARGUMENTS variable. So what I'm asking for here is that when this command is used, I'll be specifying that you're implementing a new feature. The user can then specify whatever that feature is, and then I want to make sure that Claude Code is well aware to only do this for front-end features, and to write the changes made to a file called frontend-changes.md You can imagine there are many different use cases for custom commands, certain ways you want to run tests or run files. and anything that you put in here does not automatically get added to your context, unlike a CLAUDE.md So if you want something to be applied to every single instance of Claude Code that you make, use your CLAUDE.md file. But if you just have specific commands that you may or may not use across different conversations, right here is a great place to put them. I'm going to be using this custom command when I start talking about worktrees. But before we do that, let's quit out of Claude Code, hop back in and just verify that we can see that custom command. And here, I see implement feature, and I see the description is coming from the first part of this markdown file. Now that I've added this custom command, let's go ahead and add and commit it. I could do this from the command line, but I'm actually going to ask Claude to do that for me. Add and commit changes made. This is nice so that Claude Code can create a nice commit message with some descriptive information for what was done. We'll see that it's adding the .claude folder and committing with the commands necessary. We can see here that this has been added to the repository. And since we've granted permissions for this already, we don't have to respond again. If you're ever curious where that lives, inside of the claude folder, there is a settings.local.json file Inside of this file, we can specify what commands we've allowed so that we don't need to confirm every single time. As you can see here, as well, when we use playwright, we gave permissions. And if you'd like to add your own, you can easily do so in this file, or even with the handy /permissions command. Now that we've got that custom command set up, let's talk a little bit about how we might want to work in parallel with Claude Code. Instead of just opening up multiple terminal windows and working directly on this code base, we're going to use Git to make sure that we don't overwrite existing files when we have multiple instances of Claude Code. I might have two different instances of Claude Code operating on the same file. And if I do that with the environment that I'm in right now, there's going to be overwriting, bug creation and quite a bit of confusion. Thankfully, Git has an excellent option here to use a feature called worktrees. And worktrees allow me to essentially create copies of the codebase, operate in isolation, and then at the end, merge those in together. And in fact, I can use Claude to help with that merging and management of my worktrees. To get started with worktrees, I'm going to first make a folder called .trees And inside of this worktrees folder, I'm going to go ahead and add a couple worktrees. Let's add a work tree using the Git worktree add command. and then we'll specify the folder as well as the name of the work tree that I want to add. We'll call this one ui_feature. We'll then go ahead and add another one called testing_feature, and then finally a third one called quality_feature. To confirm I've created all of these, I can take a look and I can see that I'm on the main branch currently and that I've created three separate worktrees. To set up correctly in each of these environments, I'm going to open up the trees folder, and I'm going to open up a terminal for each one of them. I'll start with my ui_feature and bring that over here. I'll then go ahead, bring in my testing feature, and I'll move that right to the side. Finally, let's bring in our quality_feature. Go ahead, bring that over up here. To give us a little more room, we'll make this a bit smaller. And now we have three dedicated terminal windows. And we'll hide the explorer as well. Now, let's open up Claude for each one of these environments. What we can do now is run Claude Code in parallel and make sure that if the same files are modified, we're not overwriting and we can fix that later when we merge in these worktrees. I'm going to use this implement-feature command. And then I'm going to put in a particular feature that I'd like here. And that feature allows me to add a toggle button to switch between dark and light themes. So let's go ahead and create a toggle button, position it, and make sure that I can navigate for this particular toggle button. We'll start with this part and then add in the light theme variant. While this is running, I can now move to another work tree. And in this second work tree, let's start thinking a little bit about what I want to do for this testing framework. going to pass in a prompt here to enhance the existing testing framework and add additional tests for FastAPI endpoints. While that's going, let's add some essential code quality tools to our development workflow. As we do this, we can start to see that changes are being requested. So let's go ahead and shift between these environments and confirm the changes that we want. Our tests are being written and our additional development dependencies for analyzing code base structure and formatting are being added as well. What we're going to see here is that we're modifying a file called pyproject.toml And we're also going to see that there's a request being added to edit that particular file as well. As we continue these options will make edits to these files, and we'll go ahead and see at the same time that our front end code is being done as expected. We can work in parallel and make sure that none of these particular changes are being overwritten by other parts of the codebase. If there happen to be changes that we've made to similar files, we can ensure that those merge conflicts are fixed. and we can do that using Claude. Our front-end changes are being written, we're adding more tests, and we're adding some formatting tools and development scripts for quality checks. So we're going to proceed as expected, making sure that quality scripts are being done, and it looks like our front-end features are being added. Now, add that light theme, the same way that we did previously. We'll use our implement feature, custom command to make sure we're writing that to our change log. and we'll add a light theme as well. Once that's done, we'll go ahead and cue up a few other prompts we'd like for JavaScript functionality and implementation details. So while that's running, I can check in on other scripts. I can confirm I want to run those, and if there's something going on, Claude Code can fix per necessary. Seems like there are some scripts that Claude doesn't know about, so we'll go ahead and either install dependencies or make sure we're running things as expected. You can see here, we're starting from code quality checks. We've written our API endpoint testing and we're adding more front end functionality. Once this is all done, we can head over to the browser. We can confirm our checks are done, but before we go ahead and do that, let's bring in all of these individual changes. If we wanted to run the tests, we can confirm this is as expected. We want to head to the browser for our UI testing, we can do so. And here we can see Codebase formatting is done, Development scripts have been added, and documentation has been updated. We saw before there was a the pyproject.toml file that was added across two different worktrees. So there might be some conflicts when figuring out these individual pieces. Now that we feel good about each of these changes, let's add and commit with a descriptive message. Let's also do the same thing on this work tree. Since we're going to be merging in these particular commits, we're going to want to make sure we have descriptive commit messages we can understand what was done in each of these worktrees. We've committed this particular commit, we're doing the same on this one right here. We finished up our UI enhancement. So let's do the same. add and commit with a descriptive message. If you find yourself writing these kinds of prompts like add and commit with a descriptive message, this also could be another use case for a nice custom command where we can specify exactly some styling that we want or the way that our company operates with best Git practices. Now that I finished committing across all three of these, I can now go back to my main branch and merge some things in. So I'm going to close these terminal environments and hop back to our main one. So now I'm going to ask Claude... To use the Git merge command to merge in all of the worktrees in the .trees folder and fix any conflicts if there are any. So let's have Claude Code merge all of these particular trees and make sure that they work as expected. We can see here there are three worktrees available. So we're going to start by merging in each of these worktrees. We'll confirm this is the command we want to use, and then this should work as expected. Looks like our testing feature doesn't have any conflicts. Let's bring on our UI feature. And again, we could write these commands on our own, but Claude Code knows exactly what to do from our prompt. Now we can merge in the quality feature branch. And here we'll see if there are any conflicts. and as we can see, in this particular file, there are conflicts. So what we're going to have Claude Code do is analyze these conflicts and complete the merge. This can be quite valuable when you have small merge conflicts that you don't want to manually go through each time. Having tests here is also quite valuable to make sure that once we've finished, we could run our tests and the code base works as expected. It's now continuing with the merge as expected. and it's going to commit all of these changes with the resolved merge conflicts. If I'd like after, I can ask for it to remove these worktrees or I can keep them there if I need. So I'll do a quick test to make sure that these files are here as expected and that the merge configurations are what are expected here as well. We can also head back to the browser and see if our front end changes are implemented as expected. Looks like Claude Code has finished up, we've added necessary dependencies, we've modified our pyproject.toml We've added tests. we've implemented the light dark themes. We've implemented our black code formatter to make sure that code is as expected in a certain format. and added that configuration in the same file that we worked on with another work tree. We fixed up any conflicts. Let's make sure this is working as expected. So back in the browser, I now see here, I have this lovely theme and as I toggle through, I can see a light theme and a dark theme. So there might be some more things I want to tweak here and there, but I've been able to edit across all parts of the stack, even do things in the linting and DevOps side of things, all without overwriting, causing challenging headaches through the power of Git worktrees. In the next lesson, we're going to see how we can use Claude Code outside of the terminal through an integration with GitHub to allow for reviewing pull requests, making changes and being helpful outside of the terminal ecosystem.

## Exploring Github Integration & Hooks

In this lesson, you'll learn how to use Claude Code outside of the terminal with a GitHub integration. You'll see how to set up Claude Code to review pull requests and fix issues in GitHub. You'll then learn how to execute code before and after using tools through Claude Code hooks. Let's dive in. We left off in the last section merging our wortrees together, but we forgot to ask Claude to remove those worktrees. So we're going to hop back into Claude. So I'm going to go and pass in the resume flag to go back to a previous conversation that I had with my worktrees. In this particular conversation, we can now go back to where we were before and finish up with removing our worktrees. So let's ask Claude, remove the .trees folder and the underlying worktrees, and once you're done, push this code to GitHub. So let's go ahead and give Claude Code a second to run the necessary git commands to remove that folder and then pushed our merge code to GitHub. We'll go ahead and give Claude Code access to see the underlying worktrees so that we not only remove the worktrees, but also delete the corresponding branches. We'll go ahead and remove these particular trees. now remove the directory and then remove the underlying branches. Now that we've done that, let's go ahead make sure that worked as expected, which is good. we don't have that folder. And now, let's push this code to GitHub. We'll confirm that we want to run the git push origin main command and it looks like our code is pushed to GitHub. Now that we've committed and pushed our code to GitHub, let's start installing the GitHub integration that comes with Claude Code. I'll do that using the /install-GitHub-app command. Here you might see that you need to include additional authentication using the command line interface. So if you see those setup instructions, make sure to follow them. We'll now be able to install the GitHub app for the current repository that we're working in. So let's go ahead and do that. This will open up the browser. And if I have not yet configured this, I'll have the option to install. What this integration allows us to do is use Claude Code in pull requests and issues to respond to feedback, fix errors, modify code, and much more. In order for this functionality to exist, it's built on top of the software development kit that comes with Claude Code. This SDK allows you to use Claude Code outside of the terminal interface. So let's head back to the terminal. specify the workflows we want to install. These workflows allow for tagging Claude in issues and using Claude to automatically review code in our pull requests. Let's install both. We'll create a long-lived token. and here we'll have to authorize and authenticate with Claude. Once that's done, we can head back and we'll see that it's creating the repository information, setting up any additional information I need, and sending me right back to GitHub to open a pull request. with the changes that had been made. We can see here automatically, this pull request allows for GitHub Actions to enable bug fixes, writing tests and code reviews. We can change this if we like, or we can go ahead and create a pull request with the default information. In this pull request, we can see that not only have we created a YAML file for Claude to operate, we also have one for code reviews. Here we can see out of the box, we have some pretty sane defaults. We can filter by authors, we can specify what this is running on. But out of the box, we get quite a bit of really nice functionality. If you'd like to modify the prompt that you have in your code review, you can do that here. And since this is a file that is tracked by git, you can constantly edit this if you need. I'm going to go ahead now and merge this in, so we can start using Claude Code in GitHub. We can go ahead and see right out of the box that a Claude GitHub action has actually started. This is what we're going to see out of the box in our future pull requests. It's going to read and analyze files, check code quality, identify security considerations, and out of the box, we now have a new teammate, Claude, to check the work that we and our other team members are doing. This sometimes takes a little bit of time to start, but once this has finished, we'll get some detailed assessments from Claude, and we'll be able to merge in the pull request when we're ready. So it looks like the review is done, and depending on the prompt that we give it, we can specify how much depth and information we want here. We see some things that are working well, maybe some considerations that we you may need. And if this looks good to us, we can merge in that pull request. Now we're going to see out of the box, in future pull requests, Claude will help review our code. This is really helpful when humans might miss certain things and you need an extra step to check that what you have is working as expected. Let's imagine there's a situation where an issue comes up. Someone on our team decides to add a new issue. We could do this in GitHub, we could even do this in Claude Code. As you might have noticed, as we kept building on top of this application, we started to see a new new header that was added. This new header might look kind of nice, but maybe we want to revert to what we had previously. So let's add an issue and see if Claude can help us out. You can imagine we have an issue here. The application has a new header that was added, Let's go back to the old one. Make sure to keep the toggle theme but just make the header look like what it was before. We'll also specify, make sure to remove the Course Materials Assistant header. Remove the subheader. around ask questions, and then remove the horizontal row below the subheader. Now that we created this issue, we could assign someone to tackle it. But why don't we just ask Claude to help us out? Claude, can you fix this for me? Once we tag in Claude, we're going to start to give Claude a little bit of time to fix the issue at hand. When Claude has fixed that issue, it should be able to generate a pull request to fix that particular one. So let's give Claude a little bit of time to find that action. Here we're going to see Claude Code is working, and if we want to see the underlying job that's run, we can go ahead and do that. So let's give Claude a little bit of time and see what it can come up with. What you're seeing is going to look very familiar to what we saw in the command line. Analyze the structure, remove the header. And here, I can even choose what to prioritize if I'd like. But what you're seeing here is the same thing we saw just outside of the terminal. Not only can we use Claude to tackle issues and pull requests, we can also use Claude to review code as we saw before. As we start to see its plan, we'll notice what the changes are that are being made, where in the codebase it's proposing things, and as we see the pull request, we can start to see some of the thinking and logic behind what's being done. Seems like this one isn't too tough, so it's going to follow these steps, test the changes, commit and push those. It's now made the commit necessary. We can see the underlying description here. If we'd like, we can create this pull request, or we can just have Claude do all that work for us. When we create the pull request. We see exactly what was generated in the commit. And now, let's go take a look and see what Claude did. We can take a look at the underlying files that we changed. There wasn't too much here. We can merge this in. As we saw before, Claude's also going to take some time and review the code that Claude wrote. And this can actually be quite helpful because as much as we want to trust Claude, it's nice to have another Claude double checking its work. So it looks like Claude Code has approved the task I have here. Let's merge this in. And then we'll head back to the terminal and make sure to pull down the changes. is that we have. So I'll head over to VS Code, pull down the changes. And let's see if our front end looks any better. And there we have it. The header is taken out, the horizontal rows taken out. We might want to bring back that horizontal row or move this to another place. But now we know how to do it, not only in the terminal, but also in GitHub. One more piece of functionality that I want to show is something that was recently released, which is the ability to add what's called a hook to Claude Code. If you're familiar here with this idea of hooks. This is going to feel very similar. The idea is that as we have different operations in Claude Code, like executing a tool or something happening after a tool, we can inject specific code to run at any point in the life cycle of Claude Code's operation. Let me show you what I mean by that. Back in VS code, I'm going to hop in back to Claude again. And while we can make these changes manually, I want to show you the editor that we have. So I'm going to type in slash hooks. manage configurations for tool events. What you're seeing might look a little bit scary, but it's our obligation to let you know. If you are running arbitrary shell commands, you have to be very careful about what you're doing. There are quite a few different events that we can run hooks. Before a tool is executed, we can even stop that tool from being executed. We can do something after, when a notification is sent, when the user submits a prompt, when something stops, or even before a subagent concludes its response. So we have the ability to programmatically to tap in to any of these events. I want to show a simple example with a PostToolUse hook. Start by adding a matcher. In this matcher, I can specify the tools that I want to be matched for this hook to run. I'm going to add a very, very simple example here. Anytime there is a Read or anytime there is a Grep, I'm going to run a simple terminal command. The new hook or command I'm going to run is the say command. The say command, runs the computer's audio and a path for what text you'd like it to say. So if I've done this correctly, after we have read something or use the grep tool to find something in a file, our machine should say, all done. Let's add this again in our project settings. We mentioned earlier the settings.local.json file where we can specify permissions. This is also where your hooks live. Inside of our .claude, we can see in our settings.local.json, not only do we have our permissions, but we now have a hook that we've defined. PostToolUse is the name of the hook, the matcher, which if you take out will apply to anything. But here, reading or grep, go run the command say 'All done!' when we're done. Let's try this out. I'm going to quit out of Claude Code. I'm going to open it up again. read the contents of the run.sh file. This should use the read tool as expected. All done. And once it's done, it notifies us and tells us all done. Well, this is kind of a fun little example, you can imagine executing code like running tests or running linters or potentially stopping tools from being used if that's not what we want or even having Claude review itself when certain things happen. There's a lot you can do with hooks and there's so much more that's coming. So make sure to look at the documentation to see everything you can do. And you can always use Claude Code to write hooks for you and modify them accordingly. In the next section, we'll explore using Claude Code with Jupyter notebooks to create visualizations, refactor code, and operate in a slightly different environment.

## Refactoring a Jupyter Notebook & Creating a Dashboard

In this lesson we're going to look at how Claude Code can help us refactor Jupyter notebooks and create dashboards. This is a really common workflow for data scientists and analysts who want to take their exploratory work in notebooks and turn it into more robust, production-ready applications. Let me start by showing you a typical Jupyter notebook that we might want to refactor. This notebook contains some data analysis work - it loads some data, does some cleaning and processing, creates visualizations, and generates some insights. This is pretty typical of the kind of exploratory data analysis that data scientists do. But there are some problems with this notebook. First, it's all in one big file, which makes it hard to maintain and reuse. Second, the code is mixed in with the analysis narrative, which makes it hard to extract just the functional parts. Third, there's no easy way to turn this into a web application or dashboard that others can use. This is where Claude Code really shines. I can ask Claude Code to help refactor this notebook into a more structured application. Let me type: "Help me refactor this Jupyter notebook into a proper Python application with separate modules for data processing, visualization, and a web dashboard." Claude Code will analyze the notebook and create a plan for how to restructure it. It identifies the different functional components - data loading, data processing, visualization creation, and analysis logic. Then it suggests how to break these into separate Python modules. Claude Code will create a src directory with separate modules for each component. For example, it might create a data_processing.py file that contains all the data loading and cleaning functions, a visualization.py file that contains the plotting functions, and an analysis.py file that contains the core analysis logic. But Claude Code goes beyond just breaking up the code. It also helps create a web dashboard using frameworks like Streamlit or Dash. Let me ask it to create a Streamlit dashboard: "Create a Streamlit dashboard that uses these refactored modules to display the analysis interactively." Now Claude Code will create a dashboard.py file that uses Streamlit to create an interactive web interface. This dashboard will import the functions from our refactored modules and present them in a user-friendly web interface. The dashboard might include things like file upload widgets, parameter controls, interactive plots, and downloadable results. This is a huge improvement over the original notebook because now we have a clean, modular codebase and a web interface that anyone can use without needing to understand Jupyter notebooks. Let me show you what the refactored structure looks like. We now have a proper project structure with separate modules, configuration files, and a main dashboard application. Each module has clear responsibilities and can be tested and maintained independently. The dashboard provides an intuitive interface for users to upload their own data and run the analysis. Claude Code also helps with creating proper documentation and tests for the refactored code. I can ask it: "Create documentation and tests for these refactored modules." And it will generate proper docstrings, README files, and unit tests that ensure the refactored code works correctly. Another really cool feature is that Claude Code can help optimize the performance of the refactored code. The original notebook might have been fine for exploratory analysis, but when we turn it into a web application, we might need to optimize for speed and memory usage. Claude Code can suggest improvements like caching expensive computations, using more efficient data structures, or implementing lazy loading for large datasets. Claude Code also helps with deployment. I can ask it: "Help me deploy this dashboard to a cloud platform." And it will help set up the necessary configuration files, Docker containers, and deployment scripts to get the application running on platforms like Heroku, AWS, or Google Cloud. The whole process from notebook to deployed web application can be completed with Claude Code's help in a fraction of the time it would normally take. And because Claude Code follows best practices, the resulting application is much more maintainable and robust than the original notebook. This workflow is incredibly powerful for data teams. It means that data scientists can focus on the analysis and insights, while Claude Code handles the engineering tasks of refactoring, testing, documentation, and deployment. It bridges the gap between exploratory data analysis and production applications. In our next lesson, we'll look at how Claude Code can help create web applications from Figma mockups, showing how it can work with design files to generate functional user interfaces.

## Creating Web App based on a Figma Mockup

In this last lesson, you'll connect Claude to the Figma MCP server to import a design mockup to Claude Code and develop the application. Let's have some fun. Now that we've seen how to use Claude Code to get up to speed on code bases to create applications and work across many different environments, I want to showcase a really powerful ability for Claude Code to work alongside MCP servers, to take mockups from tools like Figma and turn them into web applications quickly. In order to do that. We're going to be making use of the Figma MCP server. And in order to do that, you will need a Figma account. We'll also provide an alternative if you want to use that without subscribing to Figma as dev mode. We're also going to be using our Playwright MCP server, so that we can analyze a mock up from Figma, generate the necessary HTML and then programmatically test that by opening it in the browser and taking screenshots of how best to interact with this application. Since I'm building a front end application with a more modern technology stack, I'm going to be using Next.js to do that. So I'm just going to start by creating a Next.js application with the latest version inside of the folder that I'm in. I'll follow most of these same defaults, and I'll go ahead and let it install the necessary dependencies. If you have not worked with Next.js before, that's more than fine. It's a couple of command line commands and then will be in the browser before you know it. While this is installing, let's go take a look at the mockup that we have in Figma. In Figma, I have a mock right here for a dashboard that I'd like to build using Federal Reserve Economic data. This mock right here in Figma is not the most detailed in terms of all the layers and all the analytics behind, but this is enough to get me started. What I'm going to do in Figma is first, make sure that I have gone to preferences and selected enable dev mode MCP server. Once I have that selected, I'm going to take this particular layer that I have and copy it because I'm going to need that when I specify what to use with the MCP server. Now that I've successfully created this Next.js application, we need to add to Claude the two MCP servers that I want to use for Figma and for Playwright. I'm going to go ahead and add the necessary command here to bring in the MCP server for Figma. And then I'll do the same for Playwright. So I'm going to add an MCP server for Playwright, and that is started locally using the following command. And even though we already added this, remember we're in a separate project and a separate environment. So this does not get applied to every single Claude Code application I built. We have to do this for each one to make sure I've done this correctly. I'm going to hop into Claude and I'm going to use the slash MCP command to make sure this looks good. If I take a look, I can see that both of these are connected. And if I take a look at the dev mode MCP server, I can see there are five tools available to get underlying code, to get an image, to get design rules around a particular mock up that I have in Figma. Now that we've connected to both of our MCP servers, let's go and ask Claude to use the following Figma mockup and the Figma MCP server to analyze and build the underlying code necessary. We'll ask it to use the recharge library for creating charts, and then we'll check how this application looks using the Playwright MCP server. But before I do this, I want to go ahead and make a quick change. If you are able to make this change and you're not on the pro plan, you can use Opus as a different model. If not, Sonnet will still do a fine job, but Opus will do slightly better for a little bit more of a complex task. Once I have switched to that model, let's go ahead and run our prompt and see how it does. Well, first need to connect to our MCP servers. Make sure we use the correct mock up and the tools necessary to read the underlying code to power this mock. Here we can see we're using the Get image tool from the Figma dev MCP server, followed by the Get Code tool to get the underlying code behind that mock. We'll then make sure we install the necessary dependencies using npm or the package manager. And here we're going to see it's not installed. So Claude Code is most likely going to ask us to install that. We'll do so and continue onwards. Since we're inside of this Next.js application. We're going to be doing the majority of the work in the app folder. We'll analyze any global CSS and here start creating the main dashboard structure. Here we're going to add a little bit of metadata. And this looks good. So for future edits I'll just let Claude go ahead and run those. We're now going to create the dashboard layout and build this with more of a component based architecture in react. Now that we've created the underlying structure, let's start to make sure things look as expected. And since I've already run the server here, I'm just going to say don't run the server. It's already running. Continue on. We're now going to test with Playwright and take a look at how things are. We'll go ahead and navigate to localhost 3000. Take a picture of that as well. And let's go ahead and let it take a screenshot. We can see here in Playwright. So far it's looking pretty good compared to the mock. We've got a little extra styling on some of these bars, but this is a pretty good start from where we began with the mock right over here. In fact, I'd actually argue this looks a little bit nicer. We're still going to see some changes that are being made. There's a layout in the sidebar that needs to be modified, and we can always have Claude go back and forth and iterate across this particular mock. One important thing to mention is that this mock in Figma does not have a tremendous amount of layers and underlying components. So a lot of this is going to depend on the quality of the underlying mock that you have. But this is a really good start with very minimal amount of time. We can see here what's been built and what's closely matching. Now let's take a look at how things are. We can see with a little bit of work from the model and using MCP servers to verify visualizations and build off our mocks. Things that might have taken days to do and build from scratch can be done over the course of minutes. So you might be wondering what comes next here. This mock that we have is just the start of what you might imagine building. And this data is actually available through an API. So I could ask Claude Code, populate these charts with real world data from the Federal Reserve Economic data. We'll go ahead and ask Claude Code to use one of its web search tools to go ahead and find information to update with actual data. Here we'll look at CPI, unemployment yields and so on. But you can imagine this might be data that you're fetching from a back end. But here we're going to showcase Claude's ability to research how to work with the API documentation how to fetch data. And it might be possible that we need an API key to do so. So as we start doing some of this research, Claude is going to let us know what we need to make sure things are working as expected. In that mock, there were a couple other pieces in the nav bar that were just meant for visualizations, but we can add whatever underlying functionality we want next. So after it's done some research, it realizes that in order for me to fetch actual data from the Federal Reserve, I'm going to need to put in an API key. I can go ahead to my account, get an API key. This is a relatively simple process that you can see here. Once I have my API key, it's going to start writing additional code for me to fetch data and display data visually. So I'm going to go ahead and update my API key inside of here. Now that I've updated the API key, let's see where cloud is at with building additional data. It's now written a service to fetch economic data. We're now going to update the dashboard and fetch real data using our API. We're going to test this in Playwright. And we're going to go ahead and then take a look at what we have in the browser. We'll go see how this looks visually. And if there's any underlying code that needs to be modified to make this more visually appealing, with just a little bit of prompting, we can go from a mock with some fake data to actually using real world information across a true data source for this data. When we're done, we'll head back to localhost 3000. Take a look at what we have and see that the data that we'll be fetching is not something that's actually fictitious, but real unemployment, ten year treasuries and so on. We set up quite a bit here to proxy our requests and quite a few more interactive features. So let's go see what that looks like. We've gone from our mock here with some fake data and not a lot of functionality to something quite powerful. In just a short period of time. The data we're loading here has data that is actually reflective of real world information. And as we imagine adding more functionality, we can tab through for what this will look like. But with just a small amount of work with an MCP server pulling data from real world environments and building UI from Figma mocks, you can start to imagine how quickly front end development can go, especially for building powerful real world interfaces. You might want to verify that this data is actually coming from the source, and we built that here with this detailed functionality. So we can easily see where this data is coming from, what things look like, and track that back to the dashboards that we're building as well. So right here we're just showing some key indicators. But maybe the next thing I want to do is start building my own interface or use another Figma mark for things like inflation, employment and so on. So we'll start with this piece of data, but I'd love to see what else you can build using this interface and all the data at your fingertips.

## Conclusion

Congratulations on making it this far. You've learned how to use Claude Code to explore, test, refactor, and debug code bases. You can make the best out of Claude Code when you give it clear instructions, clarify the context, and point it to the relevant files in your codebase. Make sure to add your codebase rules to CLAUDE.md and any information that you'd like Claude Code to remember about your project. Consider extending Claude Code capabilities and connecting it to MCP servers like Playwright and Figma. Thank you for joining me on this journey. and I can't wait to see what you'll build with Claude Code.